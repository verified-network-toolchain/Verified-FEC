(*The results we need about the specific Vandermonde matrix over the field of bytes (really, these results hold over
  any field generated by a primitive element, but we only need (and prove) the results for the byte field.
  We use a separate file because we need to very careful about the order of imports between VST and ssreflect*)
Require Import VST.floyd.functional_base.
From mathcomp Require Import all_ssreflect.
Require Import mathcomp.algebra.matrix.
Require Import mathcomp.algebra.ssralg.
Require Import mathcomp.algebra.poly.
Require Import mathcomp.algebra.polydiv.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
Set Bullet Behavior "Strict Subproofs".
Require Import ByteField.
Require Import ListPoly.
Require Import CommonSSR.
Require Import PolyField.
Require Import BoolField.
Require Import Vandermonde.
Require Import ByteFacts.
Require Import Gaussian.

(** Results about the Weight Matrix*)

Notation B := byte_fieldType.


Section PrimitiveVandermonde.

Local Open Scope ring_scope.


Definition bx : byte := qpoly_to_byte (qx p256_geq_2).

(*Because the C code actually reverses the rows, we need rev of the natural choice 1, x, x^2, etc*)
Definition vandermonde_powers m n : 'M[B]_(m, n) := vandermonde m n (rev (map (fun i => (bx ^+ i)) (iota 0 n))).

(*Alternate definition, useful for rewriting*)
Lemma vandermonde_powers_val: forall (m n: nat) (i : 'I_m) (j: 'I_n),
  vandermonde_powers m n i j = (bx ^+ (i * (n - j - 1))).
Proof.
  move => m n i j. rewrite /vandermonde_powers /vandermonde mxE.
  have Hjsz: (nat_of_ord j < size (iota 0 n))%nat by rewrite size_iota. rewrite -map_rev.
  have->: [seq bx ^+ i0 | i0 <- rev(iota 0 n)]`_j = bx ^+ (n - j - 1). {
  rewrite (nth_map 0%nat) => [|//]. rewrite nth_rev=>[|//]. rewrite size_iota nth_iota.
  by rewrite add0n -subnDA addn1. apply rev_ord_proof. by rewrite size_rev. }  
  by rewrite GRing.exprAC GRing.exprM.
Qed.

(*TODO: see exact form we need, then prove this*)(*
Lemma vandermonde_powers_val_mod: forall (m n: nat) (i: 'I_m) (j: 'I_n),
  vandermonde_powers m n i j = (bx ^+ ( i * (n - j - 1) mod 256)).
Proof.
Admitted. *)

(*Now we need to prove [strong_inv] for this matrix*)

Lemma qpoly_to_byte_mul: forall q1 q2,
  qpoly_to_byte (@GRing.mul qpoly_p256_fieldType q1 q2)  = (qpoly_to_byte q1) * (qpoly_to_byte q2).
Proof.
  move => q1 q2. have->:(qpoly_to_byte q1 * qpoly_to_byte q2) = byte_mul (qpoly_to_byte q1) (qpoly_to_byte q2) by [].
  by rewrite /byte_mul !qpoly_byte_cancel.
Qed. 

Lemma qpoly_to_byte_pow: forall (q: qpoly (Poly p256)) i,
  qpoly_to_byte (@GRing.exp qpoly_p256_fieldType q i) = (qpoly_to_byte q) ^+ i.
Proof.
  move => q i. elim : i => [| n IH /=].
  - rewrite !GRing.expr0. apply byte_to_qpoly_inj. by rewrite qpoly_byte_cancel byte_one_qpoly.
  - rewrite !GRing.exprS. by rewrite -IH qpoly_to_byte_mul.
Qed.

(*To reduce duplication. This is a straightforward application of the injectivity of [qpow_map]
  by requires work to construct and unwrap the ordinals*)
Lemma qpow_map_nonzero_inj: forall x y,
  (x < 255)%N ->
  (y < 255)%N ->
  x != 0%N ->
  (@GRing.exp qpoly_p256_fieldType (qx p256_geq_2) x) = qx p256_geq_2 ^+ y ->
   x = y.
Proof.
  move => x y Hx Hy Hx0.
  have Hxbound: (x < #|finalg.FinRing.Field.eqType bool_finFieldType| ^ (size (Poly p256)).-1)%N.
    rewrite card_bool size_p256 //=. have->:(2 ^ 8)%N = 256%N by []. by apply (ltn_trans Hx).
  have Hybound: (y < #|finalg.FinRing.Field.eqType bool_finFieldType| ^ (size (Poly p256)).-1)%N.
    rewrite card_bool size_p256 //=. have->:(2 ^ 8)%N = 256%N by []. by apply (ltn_trans Hy).
  case Hy0: (y == 0)%N.
  - apply (elimT eqP) in Hy0. subst. rewrite GRing.expr0 => Hxy.
    have Hx255: ((@GRing.exp qpoly_p256_fieldType (qx p256_geq_2) x) = qx p256_geq_2 ^+ 255)
      by rewrite Hxy prim_fieldsize.
    have H255bound: (255 < #|finalg.FinRing.Field.eqType bool_finFieldType| ^ (size (Poly p256)).-1)%N
      by rewrite card_bool size_p256.
    have Hpows: qpow_map p256_irred p256_geq_2 (Ordinal Hxbound) = qpow_map p256_irred p256_geq_2 (Ordinal H255bound). {
      rewrite /qpow_map. have->:nat_of_ord (Ordinal Hxbound) == 0%N = false. rewrite /=. by apply negbTE. by []. }
    apply (bij_inj (qpow_map_bij p256_irred p256_primitive' p256_geq_2)) in Hpows. 
    apply (congr1 (@nat_of_ord _)) in Hpows. rewrite /= in Hpows. subst. by rewrite ltnn in Hx.
  - move => Hxy.
    have Hpows: qpow_map p256_irred p256_geq_2 (Ordinal Hxbound) = qpow_map p256_irred p256_geq_2 (Ordinal Hybound). {
      rewrite /qpow_map. have->:nat_of_ord (Ordinal Hxbound) == 0%N = false. rewrite /=. by apply negbTE.
      by rewrite Hy0. }
    apply (bij_inj (qpow_map_bij p256_irred p256_primitive' p256_geq_2)) in Hpows. 
    apply (congr1 (@nat_of_ord _)) in Hpows. rewrite /= in Hpows. by subst.
Qed.

Lemma bx_pows_inj: forall i j,
  (i < 255)%N ->
  (j < 255)%N ->
  bx ^+ i = bx ^+ j ->
  i = j.
Proof.
  move => i j Hi Hj. rewrite /bx => Heq.
  apply (congr1 byte_to_qpoly) in Heq.
  move: Heq. rewrite -!qpoly_to_byte_pow !qpoly_byte_cancel.
  case Hi0: (i == 0%N).
  - apply (elimT eqP) in Hi0. subst.
    case Hj0: (j == 0%N).
    + apply (elimT eqP) in Hj0. by subst.
    + move => Hij. apply esym in Hij. apply qpow_map_nonzero_inj in Hij; try by []. by rewrite Hj0.
  - move => Hij. apply qpow_map_nonzero_inj in Hij; try by []. by rewrite Hi0.
Qed.

(*We need the above in order to prove our lists are uniq for proving the variable vandermonde submatrices invertible*)
Lemma power_list_uniq: forall (n: nat),
  (n < 256)%N ->
  uniq (map (fun i => (bx ^+ i)) (iota 0 n)).
Proof.
  move => n Hn. rewrite map_inj_in_uniq. by rewrite iota_uniq.
  move => x y. rewrite !mem_iota !add0n => /andP[Hxgt Hxn] /andP[Hygt Hyn].
  have Hyup: (y < 255)%N by apply (ltn_leq_trans Hyn).
  have Hxup: (x < 255)%N by apply (ltn_leq_trans Hxn).
  by apply bx_pows_inj.
Qed. 

(*Now we deal with the matrices more directly*)

Lemma vandermonde_remove_col_list: forall m n (Hmn: (m <= n)%N) l (r:'I_m) (j: 'I_m),
  submx_remove_col (@vandermonde B m n l) Hmn r j = vandermonde r r (rem_nth (take (r.+1) l) j).
Proof.
  move => m n Hmn l r j. rewrite /submx_remove_col /vandermonde -matrixP /eqrel => x y.
  rewrite !mxE. rewrite rem_nth_nth /=. case Hyj: (y < j)%N.
  - rewrite /=. rewrite nth_take. by []. have Hyr: (y < r)%N by []. by apply (ltn_trans Hyr).
  - rewrite /=. rewrite nth_take. by []. by rewrite -(addn1 y) -(addn1 r) ltn_add2r.
Qed.

Lemma vandermonde_remove_col_unitmx: forall m n (Hmn:( m <= n)%N) (r: 'I_m) (j: 'I_m),
  (j < r)%N ->
  (n < 256)%N ->
  submx_remove_col (vandermonde_powers m n) Hmn r j \in unitmx.
Proof.
  move => m n Hmn r j Hjr Hnbound.
  rewrite vandermonde_remove_col_list. apply vandermonde_unitmx.
  - apply rem_nth_uniq. apply 0. apply take_uniq. rewrite rev_uniq. by apply power_list_uniq.
  - have Hsz: size (take r.+1 (rev  [seq (@GRing.exp _ bx i) | i <- iota 0 n])) = r.+1. {
    rewrite size_take size_rev size_map size_iota.
    have Hrm: (r.+1 <= m)%N by []. have: (r.+1 <= n)%N by apply (leq_trans Hrm Hmn).
    rewrite leq_eqVlt => /orP[/eqP Hr1n | Hr1n].
    + rewrite Hr1n. rewrite ltnn -Hr1n. apply pred_Sn.
    + rewrite Hr1n. apply pred_Sn. }
    rewrite rem_nth_size; rewrite Hsz. apply pred_Sn. by apply (ltn_trans Hjr).
Qed.

(* The row matrix is much more complicated.
  Let P be the original powers matrix. Then p_ij = x^i(n-j-1).
  So row i consists of x^i(n-1), x^i(n-2),..., x^i(n-r). We cannot simply take the transpose, because this
  is the reverse of a vandermonde matrix - every column goes in decreasing powers of x.
  So we proved a result that we can flip all the rows while preserving invertibility, allowing us to 
  get x^i(n-r), x^i(n-r+1),... in each column (after transpose). But this is still not good enough, since
  we start with some extra powers of x (ie, a column might be x^4, x^6, x^8,...). So before doing the above,
  we first scalar multiply each row i by p_ir^-1 = x^-(i(n-r-1)).
  So the transformations are as follows:
  p_{ij} = x^{i(n-j-1)}
  p1_{ij} = x^{i(r-j)} (scalar multiply)
  p2_{ij} = x^{j(r-i)} (transpose)
  p3_{ij} = x^{ji} (flip all rows (i -> r.+1 - i - 1)
  Finally, p3 is a vandermonde matrix, so it is invertible. Since all of these transformations preserve
  invertibility, p is also invertible. *)



Definition scalar_mult_last_inv {m n} (Hn: (0 < n)%N) (A: 'M[B]_(m, n)) : 'M[B]_(m, n) :=
  foldr (fun (r: 'I_m) acc => sc_mul acc (A r (pred_ord Hn))^-1 r) A (ord_enum m).

Lemma scalar_mult_last_inv_val: forall {m n} (Hn: (0 < n)%N) (A: 'M[B]_(m, n)) i j,
  scalar_mult_last_inv Hn A i j = (A i j) * (A i (pred_ord Hn))^-1.
Proof.
  move => m n Hn A i j. rewrite mx_row_transform.
  - by rewrite /sc_mul mxE eq_refl GRing.mulrC.
  - move => A' i' j' r Hir'. rewrite /sc_mul mxE. 
    by have->:(i' == r = false) by move: Hir'; case (i' == r).
  - move => A' B r Hin Hout j'. by rewrite /sc_mul !mxE eq_refl Hin.
  - apply ord_enum_uniq.
  - apply mem_ord_enum.
Qed.

Lemma qx_not_zero: bx != 0%R.
Proof.
  case: (bx == 0) /eqP => [ |//].
  rewrite /bx. have->:0%R = Byte.zero by []. move => Hx.
  apply (congr1 byte_to_qpoly) in Hx. move: Hx. rewrite qpoly_byte_cancel byte_zero_qpoly => Hx0.
  pose proof (qx_0 p256_irred p256_geq_2) as Hxnot0. move: Hxnot0. by rewrite Hx0 eq_refl.
Qed. 

(*This is the big lemma that will allow us to prove the transpose of this matrix equivalent to a vandermonde mx*)
Lemma scalar_mult_last_inv_vandermonde_powers: forall {m n} (Hmn: (m <= n)%N) (r : 'I_m) y i j,
  (r <= nat_of_ord y)%N ->
  (scalar_mult_last_inv (ltn0Sn r) (submx_add_row (@vandermonde_powers m n) Hmn r y)) i j = 
    bx^+ ((if (i < r)%N then nat_of_ord i else nat_of_ord y) * (r-j)).
Proof.
  move => m n Hmn r y i j Hry. rewrite scalar_mult_last_inv_val !mxE.
  have /eqP Hord: nat_of_ord (widen_ord (leq_trans (ltn_ord r) Hmn) j) == j by []. rewrite !Hord.
  have /eqP Hord' : nat_of_ord (widen_ord (leq_trans (ltn_ord r) Hmn) (pred_ord (ltn0Sn r))) == r by [].
  rewrite {Hord} !Hord' {Hord'} !nth_rev; rewrite !size_map size_iota.
  have Hnsub: forall p, (n - p.+1 < n)%N. { move => p. rewrite ltn_subrL ltn0Sn /=.
  have: (0 <= n)%N by []. rewrite leq_eqVlt => /orP[Hn0 | //]. eq_subst Hn0.
  have Hrm: (r < m)%N by []. rewrite leqn0 in Hmn. eq_subst Hmn. by []. }
  rewrite !(nth_map 0%nat); try (by rewrite size_iota). rewrite !nth_iota; try (by rewrite Hnsub).
  rewrite !add0n.
  have Hsimpl: forall (z : nat),
  (@GRing.exp B bx (n - j.+1)) ^+ z / bx ^+ (n - r.+1) ^+ z = bx ^+ (z * (r - j)). {
  move => z. have: (0 <= z)%N by []. rewrite leq_eqVlt => /orP[Hz0 | Hz].
  + eq_subst Hz0. rewrite -!GRing.exprM !muln0 mul0n !GRing.expr0. apply GRing.mulfV.
    apply GRing.oner_neq0.
  + have: (j <= r)%N by rewrite ltnSE. rewrite leq_eqVlt => /orP[Hjreq | Hlt].
    - eq_subst Hjreq. rewrite Hjreq subnn muln0 GRing.expr0. apply GRing.mulfV.
      rewrite -GRing.exprM. rewrite GRing.expf_neq0. by []. apply qx_not_zero.
    - rewrite -!GRing.exprM. rewrite -!GRing.Theory.expfB.
      2: { have Hjr1: (j.+1 < r.+1)%N by []. rewrite ltn_mul2r Hz /=.
        apply ltn_sub2l.
        have Hrm: (r.+1 <= m)%N by []. have Hjm: (j.+1 < m)%N by apply (ltn_leq_trans Hjr1 Hrm).
        apply (ltn_leq_trans Hjm Hmn). by []. }
      rewrite -mulnBl subnBA. rewrite -addnABC. rewrite addnC -subnBA. 
      by rewrite subnn subn0 subSS mulnC. by rewrite leqnn.
      have Hjm: (j < m)%N by apply (ltn_trans Hlt). by apply (ltn_leq_trans Hjm Hmn). by [].
      have Hrm: (r < m)%N by []. by apply (ltn_leq_trans Hrm). }
  have: (i <= r)%N by rewrite ltnSE. rewrite leq_eqVlt => /orP[Hireq | Hlt].
  - eq_subst Hireq. rewrite Hireq ltnn. apply Hsimpl.
  - rewrite Hlt /=. apply Hsimpl.
  - have Hrm: (r < m)%N by []. by apply (ltn_leq_trans Hrm).
  - have Hjr: (j <= r)%N by rewrite -ltnS. have Hrm : (r < m)%N by [].
    have Hjm: (j < m)%N by apply (leq_ltn_trans Hjr Hrm). by apply (ltn_leq_trans Hjm).
Qed. 


(*The row matrix is a bit more complicated. The resulting matrix isn't Vandermonde, but
  if we transpose it and then flip all the rows, then it is. So we use the [flip_rows] result as well*)

Lemma vandermonde_powers_add_row_list: forall m n (Hmn: (m <= n)%N) (r j:'I_m),
  (r <= j)%N ->
  flip_rows ((scalar_mult_last_inv (ltn0Sn r) (submx_add_row (@vandermonde_powers m n) Hmn r j))^T) =
    vandermonde (r.+1) (r.+1) ((map (fun i => (bx ^+ i)) (iota 0 r)) ++ (bx ^+ j :: nil)).
Proof.
  move => m n Hmn r j Hrj. rewrite /flip_rows /vandermonde -matrixP /eqrel => x y.
  rewrite mxE mxE scalar_mult_last_inv_vandermonde_powers. 2: by []. rewrite  !mxE.
  have Hxn: (x < n)%N. have Hxr: (x < r.+1)%N by []. rewrite ltnS in Hxr.
    have Hrm: (r < m)%N by []. have Hxm: (x < m)%N by apply (leq_ltn_trans Hxr Hrm).
    by apply (ltn_leq_trans Hxm Hmn).
  have Hx: (r - (r.+1 - x.+1))%nat = x by rewrite subSS subKn // -ltnS. 
  have: (y < r.+1)%N by []. rewrite ltnS leq_eqVlt => /orP[/eqP Hyr | Hyr].
  - rewrite Hyr ltnn. rewrite nth_cat.
    rewrite size_map size_iota ltnn subnn /=. by rewrite Hx -GRing.exprM.
  - rewrite Hyr /=. rewrite nth_cat size_map size_iota Hyr.
    rewrite !(nth_map 0%nat) /=. rewrite !nth_iota.
    rewrite !add0n. by rewrite Hx -GRing.exprM. by []. by rewrite size_iota.
Qed.

Lemma vandermonde_add_row_unitmx: forall m n (Hmn: (m <= n)%N) (r j:'I_m),
  (r <= j)%N ->
  (n < 256)%N ->
  submx_add_row (vandermonde_powers m n) Hmn r j \in unitmx.
Proof.
  move => m n Hmn r j Hrj Hn.
  (*lots of layers to show*)
  have Hinv: row_equivalent (submx_add_row (vandermonde_powers m n) Hmn r j)
    (scalar_mult_last_inv (ltn0Sn r) (submx_add_row (vandermonde_powers m n) Hmn r j)). {
  apply mx_row_transform_equiv. move => A' r'. apply ero_row_equiv. apply ero_sc_mul.
  rewrite !mxE /=. (*need to do it here to show that not zero*)
  have Hnr: (n - r.+1 < n)%N.  rewrite ltn_subrL ltn0Sn /=. have: (0 <= n)%N by []. 
  rewrite leq_eqVlt => /orP[Hn0 | //]. eq_subst Hn0.
  have Hrm: (r < m)%N by []. rewrite leqn0 in Hmn. eq_subst Hmn. by [].
  rewrite nth_rev size_map size_iota. rewrite (nth_map 0%nat). rewrite nth_iota.
  rewrite add0n -!GRing.exprVn -GRing.exprM GRing.expf_neq0. by [].
  apply GRing.invr_neq0. apply qx_not_zero. by []. by rewrite size_iota.
  have Hrm: (r < m)%N by []. by apply (ltn_leq_trans Hrm). }
  apply row_equivalent_unitmx_iff in Hinv. rewrite Hinv {Hinv}.
  rewrite -unitmx_tr flip_rows_unitmx vandermonde_powers_add_row_list =>[|//].
  apply vandermonde_unitmx.
  - rewrite cats1 rcons_uniq.
    have->: (bx ^+ j \notin [seq (bx ^+ i) | i <- iota 0 r]). {
      case: (bx ^+ j \in [seq bx ^+ i | i <- iota 0 r]) /mapP =>[[i Hi Heq]|//]. 
      move : Hi; rewrite mem_iota add0n => /andP[H{H} Hir].
      have Hjbound: (j < 255)%N. have Hjm: (j < m)%N by []. have Hjn: (j < n)%N by apply (ltn_leq_trans Hjm Hmn).
        apply (ltn_leq_trans Hjn Hn).
      apply bx_pows_inj in Heq.
      + subst. have: (r < r)%N by apply (leq_ltn_trans Hrj). by rewrite ltnn.
      + by []. 
      + have Hij: (i < j)%N by apply (ltn_leq_trans Hir Hrj). apply (ltn_trans Hij Hjbound). }
    rewrite /=. apply power_list_uniq.
    apply (leq_ltn_trans Hrj).  have Hjm: (j < m)%N by []. apply (ltn_trans Hjm).
    by apply (leq_ltn_trans Hmn).
  - by rewrite size_cat /= size_map size_iota addn1.
Qed.

(*Finally, the result we want: The Vandermonde matrix consisting of powers of the primitive element
  satisfied [strong_inv 0]*)
Lemma vandermonde_strong_inv: forall m n (Hmn: (m <= n)%N) (Hm: (0 < m)%N),
  (n < 256)%N ->
  strong_inv (vandermonde_powers m n) Hmn (Ordinal Hm).
Proof.
  move => m n Hmn Hm Hn. rewrite /strong_inv => r' H{H}.
  split; move => j Hrj.
  - by apply vandermonde_remove_col_unitmx.
  - by apply vandermonde_add_row_unitmx.
Qed.

End PrimitiveVandermonde.

Require Import ListMatrix.
Require Import ZSeq.
Require Import Common.

(*Weight matrix definition*)
Section WeightMx.

Local Open Scope ring_scope.

(*TODO: use mod, so we dont need to prove in VST*)
Definition weight_mx_list (m n : Z) : lmatrix B :=
  mk_lmatrix m n (fun i j => bx ^+  Z.to_nat (i * (n - j - 1))).

Lemma weight_matrix_wf: forall m n, 0 <= n -> 0 <= m -> wf_lmatrix (weight_mx_list m n) m n.
Proof.
  move => m n Hn Hm. by apply mk_lmatrix_wf.
Qed.

Lemma weight_mx_list_spec: forall m n, 
  0 <= m ->
  0 <= n ->
  lmatrix_to_mx m n (weight_mx_list m n) = vandermonde_powers (Z.to_nat m) (Z.to_nat n).
Proof.
  move => m n Hm Hn. rewrite -matrixP => x y. 
  have Hx: 0 <= Z.of_nat x < m by apply (Z_ord_bound).
  have Hy: 0 <= Z.of_nat y < n by apply (Z_ord_bound). 
  rewrite vandermonde_powers_val mxE mk_lmatrix_get //=. f_equal.
  have->: (x * (Z.to_nat n - y - 1))%N = (x * (Z.to_nat n - y - 1))%coq_nat by []. (*lia and nia not enough*)
  rewrite Z2Nat.inj_mul; try lia. rewrite Nat2Z.id Z2Nat.inj_sub; try lia.
  rewrite Z2Nat.inj_sub; try lia. by rewrite Nat2Z.id Nat.mul_sub_distr_l.
Qed. 

Definition weight_mx := (gauss_restrict_rows fec_max_h (fec_n -1)
            (weight_mx_list fec_max_h  (fec_n - 1))).

Lemma weight_mx_wf: wf_lmatrix weight_mx (fec_max_h) (fec_n - 1).
Proof.
  apply gauss_restrict_rows_wf. apply weight_matrix_wf; rep_lia.
Qed.

(*TODO: maybe move*)
(*At several places in the C code, a 2d array is populated by filling in each element, in order. We abstract that out
  to make the VST proof simpler and to reduce duplication*)
(*This is a matrix where the first i rows are filled, and the (i+1)st row is filled up to j*)
Definition pop_2d_mx m n (f: Z -> Z -> B) (i j : Z) : lmatrix B :=
  mk_lmatrix m n (fun x y => if Z_lt_le_dec x i then f x y
                    else if Z.eq_dec x i then if Z_lt_le_dec y j then f x y
                    else 0 else 0).

Lemma pop_2d_mx_wf: forall m n f i j,
  0 <= m ->
  0 <= n ->
  wf_lmatrix (pop_2d_mx m n f i j) m n.
Proof.
  move => m n f i j Hm Hn. by apply mk_lmatrix_wf.
Qed. 

(*At the start, this is the zero 2D array*)
Lemma pop_2d_mx_zero: forall m n f,
  0 <= m ->
  0 <= n ->
  pop_2d_mx m n f 0 0 = (zseq m (zseq n Byte.zero)).
Proof.
  move => m n f Hm Hn. apply (@lmatrix_ext_eq B m n).
  - by apply pop_2d_mx_wf.
  - rewrite /wf_lmatrix; repeat split; [| rep_lia |].
    + rewrite zseq_Zlength; rep_lia.
    + rewrite Forall_Znth => i. rewrite zseq_Zlength; try rep_lia. move => Hi.
      rewrite zseq_Znth; try rep_lia. rewrite zseq_Zlength; rep_lia.
  - move => i' j' Hi' Hj'.
    rewrite mk_lmatrix_get; try rep_lia. rewrite /get !zseq_Znth; try rep_lia.
    case :  (Z_lt_le_dec i' 0) => [| /= _]; try rep_lia.
    case : (Z.eq_dec i' 0) => [/= Hi0 | //]. subst. 
    by case : (Z_lt_le_dec j' 0); try rep_lia.
Qed.

(*Finishing a row*)
Lemma pop_2d_mx_row_finish: forall m n f i,
  0 <= m ->
  0 <= n ->
  pop_2d_mx m n f i n = pop_2d_mx m n f (i+1) 0.
Proof.
  move => m n f i Hm Hn. apply (lmatrix_ext_eq (pop_2d_mx_wf _ _ _ Hm Hn) (pop_2d_mx_wf _ _ _ Hm Hn)).
  move => i' j' Hi' Hj'.
  rewrite !mk_lmatrix_get; try rep_lia.
  case :  (Z_lt_le_dec i' i) => [Hii' /= | Hii' /=].
  - by case : (Z_lt_le_dec i' (i + 1)); try rep_lia. 
  - case : (Z.eq_dec i' i) => [Hiieq /= | Hiineq /=].
    + subst. case : (Z_lt_le_dec i (i + 1)) => [ /=_ | ]; try rep_lia.
      case : (Z_lt_le_dec j' n) => [//|]. lia. 
    + case : (Z_lt_le_dec i' (i + 1)) => [| /= _]; try rep_lia.
      case : (Z.eq_dec i' (i + 1)) => [Hi1 /= | //].
      by case : (Z_lt_le_dec j' 0); try rep_lia.
Qed.

(*Update an element*)
Lemma pop_2d_mx_set: forall m n f i j,
  0 <= i < m ->
  0 <= j < n ->
  set (pop_2d_mx m n f i j) i j (f i j) = pop_2d_mx m n f i (j + 1).
Proof.
  move => m n f i j Hi Hj. apply (@lmatrix_ext_eq B m n).
  - apply set_wf. apply pop_2d_mx_wf; lia.
  - apply pop_2d_mx_wf; lia.
  - move => i' j' Hi' Hj'. rewrite (@get_set _ m n); try rep_lia; last first.
    apply pop_2d_mx_wf; lia. rewrite !mk_lmatrix_get; try rep_lia. 
    case: (i' =? i) /(Z.eqb_spec _ _) => [ Hiieq /= | Hiineq /=].
    + subst. case : (Z_lt_le_dec i i) => [| /= _]; try rep_lia.
      case : (Z.eq_dec i i) => [/= _|]; try rep_lia.
      case: (j' =? j) /(Z.eqb_spec _ _) => [Hjjeq //= | Hjjeq //=].
      * subst. by case : (Z_lt_le_dec j (j + 1)); try rep_lia.
      * case : (Z_lt_le_dec j' j) => [Hjj' /= | Hjj/=];  by case : (Z_lt_le_dec j' (j + 1)); try rep_lia.
    + case : (Z_lt_le_dec i' i) => [// | Hii' /=].
      by case : (Z.eq_dec i' i); try rep_lia.
Qed.

(*Finish - prove a postcondition*)
Lemma pop_2d_mx_done: forall m n f j x y,
  0 <= x < m ->
  0 <= y < n ->
  get (pop_2d_mx m n f m j) x y = f x y.
Proof.
  move => m n f j x y Hx Hy. rewrite mk_lmatrix_get //.
  by case : (Z_lt_le_dec x m) => [_ // |]; try lia.
Qed.

(*Specialize this definition to populating the weight matrix*)
Definition pop_weight_mx (i j : Z) : lmatrix B := pop_2d_mx fec_max_h (fec_n -1) 
  (fun x y => (byte_pow_map (Byte.repr ((x * y) mod 255)))) i j.

Lemma pop_weight_mx_wf: forall i j,
  wf_lmatrix (pop_weight_mx i j) fec_max_h (fec_n - 1).
Proof.
  move => i j. apply pop_2d_mx_wf; rep_lia.
Qed.

Lemma pop_weight_mx_row_finish: forall i,
  pop_weight_mx i (fec_n - 1) = pop_weight_mx (i+1) 0.
Proof.
  move => i. apply pop_2d_mx_row_finish; rep_lia.
Qed.

Lemma pop_weight_mx_zero:
  pop_weight_mx 0 0 = (zseq fec_max_h (zseq (fec_n - 1) Byte.zero)).
Proof.
  apply pop_2d_mx_zero; rep_lia.
Qed.

Lemma pop_weight_mx_set: forall i j,
  0 <= i < fec_max_h ->
  0 <= j < fec_n - 1 ->
  set (pop_weight_mx i j) i j (byte_pow_map (Byte.repr ((i * j) mod 255))) =
  pop_weight_mx i (j + 1).
Proof.
  move => i j Hi Hj. by apply pop_2d_mx_set.
Qed.

(*Relate [modn] to Z.modulo*)

(*TODO: move to commonssr*)
Lemma modn_mod_nat: forall (n1 n2 : nat),
  (0 < n2)%N ->
  (n1 %% n2)%N = (n1 mod n2)%N.
Proof.
  move => n1 n2 Hn2. apply (Nat.mod_unique _ _ (n1 %/ n2)).
  - apply /ltP. by rewrite ltn_mod.
  - have->:(n2 * (n1 %/ n2))%coq_nat = (n2 * (n1 %/ n2))%N by [].
    have->:(n2 * (n1 %/ n2) + n1 %% n2)%coq_nat = (n2 * (n1 %/ n2) + n1 %% n2)%N by [].
    by rewrite mulnC -divn_eq.
Qed.

Lemma modn_mod_Z: forall (z1 z2: Z),
  0 <= z1 ->
  0 < z2 ->
  Z.to_nat (z1 mod z2) = ((Z.to_nat z1) %% (Z.to_nat z2))%N.
Proof.
  move => z1 z2 Hz1 Hz2. rewrite modn_mod_nat; last first. apply /ltP; lia.
  apply Nat2Z.inj. rewrite mod_Zmod; try lia. rewrite !Z2Nat.id; try lia.
  by apply Z.mod_pos_bound.
Qed.

Lemma pop_weight_weight_done: forall j,
  mx_val (pop_weight_mx fec_max_h j) = rev_mx_val (weight_mx_list fec_max_h  (fec_n - 1)).
Proof.
  move => j. apply (map_2d_rev_equiv fec_max_h (fec_n - 1)).
  - apply pop_weight_mx_wf.
  - apply weight_matrix_wf; rep_lia.
  - move => i' j' Hi' Hj'. rewrite pop_2d_mx_done //.
    rewrite mk_lmatrix_get; try lia. rewrite /byte_pow_map /bx -qpoly_to_byte_pow. f_equal.
    rewrite /qpow_map_full /=. apply powX_eq_mod. rewrite Byte.unsigned_repr; last first.
    pose proof (Z.mod_pos_bound (i' * j') 255); rep_lia. rewrite modn_mod_Z; try lia.
    have->: Z.to_nat 255 = 255%N by [].
    have->: (fec_n - 1 - (fec_n - 1 - j' - 1) - 1)%Z = j' by lia.
    by rewrite modn_mod.
Qed.
 
End WeightMx.